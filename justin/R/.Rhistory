library(xcms)
library(Hmisc)
library(gtools)
# beer3 and urine37 dataset
# input_file <- '/home/joewandy/Project/justin_data/Beer_3_T10_POS.mzXML'
# input_file <- '/home/joewandy/Project/justin_data/Beer_3_T10_NEG.mzXML'
# input_file <- '/home/joewandy/Project/justin_data/Urine_37_Top10_POS.mzXML'
# input_file <- '/home/joewandy/Project/justin_data/Urine_37_Top10_NEG.mzXML'
# beer2pos and beer3pos as training-testing data
input_file <- '/home/joewandy/Project/justin_data/Beer_data/Positive/Beer_2_T10_POS.mzXML'
# input_file <- '/home/joewandy/Project/justin_data/Beer_data/Positive/Beer_3_T10_POS.mzXML'
# reuse prev vocabularies, if any
prev_fragment_file <- 'Beer_3_T10_POS_fragments_rel.csv'
prev_loss_file <- 'Beer_3_T10_POS_losses_rel.csv'
prev_mzdiff_file <- 'Beer_3_T10_POS_mzdiffs_rel.csv'
# construct the output filenames
prefix <- basename(input_file) # get the filename only
prefix <- sub("^([^.]*).*", "\\1", prefix) # get rid of the extension
# if true, we will use the relative intensities of the ms2 peaks instead of absolute intensity
use_relative_intensities <- TRUE
if (use_relative_intensities) {
fragments_out <- paste(c(prefix, '_fragments_rel.csv'), collapse="")
losses_out <- paste(c(prefix, '_losses_rel.csv'), collapse="")
mzdiffs_out <- paste(c(prefix, '_mzdiffs_rel.csv'), collapse="")
ms1_out <- paste(c(prefix, '_ms1_rel.csv'), collapse="")
ms2_out <- paste(c(prefix, '_ms2_rel.csv'), collapse="")
} else {
fragments_out <- paste(c(prefix, '_fragments.csv'), collapse="")
losses_out <- paste(c(prefix, '_losses.csv'), collapse="")
mzdiffs_out <- paste(c(prefix, '_mzdiffs.csv'), collapse="")
ms1_out <- paste(c(prefix, '_ms1.csv'), collapse="")
ms2_out <- paste(c(prefix, '_ms2.csv'), collapse="")
}
################################
## Read in data and get peaks ##
################################
# do peak detection using CentWave
xset <- xcmsSet(files=input_file, method="centWave", ppm=2, snthresh=3, peakwidth=c(5,100),
prefilter=c(3,1000), mzdiff=0.001, integrate=0, fitgauss=FALSE, verbose.column=TRUE)
xset <- group(xset)
# load Tony Larson's script
source('xcmsSetFragments.R')
frags <- xcmsSetFragments(xset, cdf.corrected = FALSE, min.rel.int=0.01, max.frags = 5000,
msnSelect=c("precursor_int"), specFilter=c("specPeaks"), match.ppm=7,
sn=3, mzgap=0.005, min.r=0.75, min.diff=10)
peaks <- as.data.frame(frags@peaks)
##########################
##### Data filtering #####
##########################
### MS1 ###
# get ms1 peaks
ms1 <- peaks[which(peaks$msLevel==1),]
# keep peaks with RT > 3 mins and < 21 mins
ms1 <- ms1[which(ms1$rt >= 3*60),]
ms1 <- ms1[which(ms1$rt <= 21*60),]
### MS2 ###
# get ms2 peaks
ms2 <- peaks[which(peaks$msLevel==2),]
# keep ms2 peaks with intensity > 5000
ms2 <- ms2[which(ms2$intensity>5000),]
# keep ms2 peaks with parent in filtered ms1 list
ms2 <- ms2[which(ms2$MSnParentPeakID %in% ms1$peakID),]
# make sure only ms1 peaks with ms2 fragments are kept
ms1 <- ms1[which(ms1$peakID %in% ms2$MSnParentPeakID),]
# scale the intensities of ms2 peaks to relative intensity
if (use_relative_intensities) {
parent_ids <- ms2$MSnParentPeakID
for (i in 1:nrow(ms1)) {
peak_id <- ms1[i, 1]
matches <- match(as.character(parent_ids), peak_id)
pos <- which(!is.na(matches))
# if there's more than one fragment peak
if (length(pos)>0) {
# then scale by the relative intensities of the spectrum
fragment_peaks <- ms2[pos, ]
fragment_intensities <- fragment_peaks$intensity
max_intense <- max(fragment_intensities)
fragment_intensities <- fragment_intensities / max_intense
ms2[pos, ]$intensity <- fragment_intensities
}
}
}
### Prepare the matrices for LDA ###
###############################
##### Feature Extractions #####
###############################
source('extractFragmentFeatures.R')
results <- extract_ms2_fragment_df(ms1, ms2, prev_fragment_file)
fragment_df <- results$fragment_df
ms2 <- results$ms2
setwd("~/git/metabolomics_tools/justin/R")
########################################
##### MS1/MS2 Dataframe Generation #####
########################################
print("Constructing MS1/MS2 dataframe")
# for existing words
existing_fragment_df <- data.frame(t(rep(NA,length(ms1$peakID))))
existing_fragment_df <- existing_fragment_df[-1,] # remove first column
# for new words
new_fragment_df <- data.frame(t(rep(NA,length(ms1$peakID))))
new_fragment_df <- new_fragment_df[-1,] # remove first column
ms1.names <- as.character(ms1$peakID) # set row names on ms1 dataframe
ms2.names <- as.character(ms2$peakID) # set row names on ms2 dataframe
# reuse existing words, if any
copy_ms2 <- ms2
if (file.exists(prev_fragment_file)) {
prev_fragment_df <- read.csv(prev_fragment_file, header=T, check.names=F, row.names=1)
prev_words <- rownames(prev_fragment_df)
tokens <- strsplit(prev_words, '_')
prev_mzs <- sapply(tokens, '[', 2)
prev_mzs <- as.numeric(prev_mzs)
prev_mzs_len <- length(prev_mzs)
for (i in 1:prev_mzs_len) {
print(paste(c("i=", i, "/", prev_mzs_len,
", remaining=", nrow(copy_ms2)), collapse=""))
mz <- prev_mzs[i]
# calculate mz window
max.ppm <- mz * 7 * 1e-06
# find peaks within that window
match.idx <- which(sapply(copy_ms2$mz, function(x) {
abs(mz - x) < max.ppm
}))
# calculate mean mz as label for ms2 row
mean.mz <- round(mz, digits=5)
# if there's a match then use the actual fragment peaks
if (length(match.idx)>0) {
# store the mean mz (bin id) into the original ms2 dataframe too
peakids <- copy_ms2$peakID[match.idx]
matching_pos <- match(as.character(peakids), ms2.names)
ms2[matching_pos, "fragment_bin_id"] <- as.character(mean.mz)
# get intensities
intensities <- copy_ms2$intensity[match.idx]
# get parent id
parent.id <- copy_ms2$MSnParentPeakID[match.idx]
# add a row of the intensities of the fragments
parent.idx <- match(as.character(parent.id), ms1.names)
row <- rep(NA, nrow(ms1))
row[parent.idx] <- intensities
existing_fragment_df <- rbind(existing_fragment_df, row)
rownames(existing_fragment_df)[nrow(existing_fragment_df)] <- paste(c("fragment_", mean.mz), collapse="")
# remove fragments from ms2 list and start loop again with next fragment
copy_ms2 <- copy_ms2[-match.idx,]
} else { # otherwise just insert a row of all NAs
row <- rep(NA, nrow(ms1))
existing_fragment_df <- rbind(existing_fragment_df, row)
rownames(existing_fragment_df)[nrow(existing_fragment_df)] <- paste(c("fragment_", mean.mz), collapse="")
}
}
}
source('extractFragmentFeatures.R')
results <- extract_ms2_fragment_df(ms1, ms2, prev_fragment_file)
print("Constructing MS1/MS2 dataframe")
# for existing words
existing_fragment_df <- data.frame(t(rep(NA,length(ms1$peakID))))
existing_fragment_df <- existing_fragment_df[-1,] # remove first column
# for new words
new_fragment_df <- data.frame(t(rep(NA,length(ms1$peakID))))
new_fragment_df <- new_fragment_df[-1,] # remove first column
ms1.names <- as.character(ms1$peakID) # set row names on ms1 dataframe
##########################
##### Data filtering #####
##########################
### MS1 ###
# get ms1 peaks
ms1 <- peaks[which(peaks$msLevel==1),]
# keep peaks with RT > 3 mins and < 21 mins
ms1 <- ms1[which(ms1$rt >= 3*60),]
ms1 <- ms1[which(ms1$rt <= 21*60),]
### MS2 ###
# get ms2 peaks
ms2 <- peaks[which(peaks$msLevel==2),]
# keep ms2 peaks with intensity > 5000
ms2 <- ms2[which(ms2$intensity>5000),]
# keep ms2 peaks with parent in filtered ms1 list
ms2 <- ms2[which(ms2$MSnParentPeakID %in% ms1$peakID),]
# make sure only ms1 peaks with ms2 fragments are kept
ms1 <- ms1[which(ms1$peakID %in% ms2$MSnParentPeakID),]
# scale the intensities of ms2 peaks to relative intensity
if (use_relative_intensities) {
parent_ids <- ms2$MSnParentPeakID
for (i in 1:nrow(ms1)) {
peak_id <- ms1[i, 1]
matches <- match(as.character(parent_ids), peak_id)
pos <- which(!is.na(matches))
# if there's more than one fragment peak
if (length(pos)>0) {
# then scale by the relative intensities of the spectrum
fragment_peaks <- ms2[pos, ]
fragment_intensities <- fragment_peaks$intensity
max_intense <- max(fragment_intensities)
fragment_intensities <- fragment_intensities / max_intense
ms2[pos, ]$intensity <- fragment_intensities
}
}
}
# load Tony Larson's script
source('xcmsSetFragments.R')
frags <- xcmsSetFragments(xset, cdf.corrected = FALSE, min.rel.int=0.01, max.frags = 5000,
msnSelect=c("precursor_int"), specFilter=c("specPeaks"), match.ppm=7,
sn=3, mzgap=0.005, min.r=0.75, min.diff=10)
peaks <- as.data.frame(frags@peaks)
##########################
##### Data filtering #####
##########################
### MS1 ###
# get ms1 peaks
ms1 <- peaks[which(peaks$msLevel==1),]
# keep peaks with RT > 3 mins and < 21 mins
ms1 <- ms1[which(ms1$rt >= 3*60),]
ms1 <- ms1[which(ms1$rt <= 21*60),]
### MS2 ###
# get ms2 peaks
ms2 <- peaks[which(peaks$msLevel==2),]
# keep ms2 peaks with intensity > 5000
ms2 <- ms2[which(ms2$intensity>5000),]
# keep ms2 peaks with parent in filtered ms1 list
ms2 <- ms2[which(ms2$MSnParentPeakID %in% ms1$peakID),]
# make sure only ms1 peaks with ms2 fragments are kept
ms1 <- ms1[which(ms1$peakID %in% ms2$MSnParentPeakID),]
# scale the intensities of ms2 peaks to relative intensity
if (use_relative_intensities) {
parent_ids <- ms2$MSnParentPeakID
for (i in 1:nrow(ms1)) {
peak_id <- ms1[i, 1]
matches <- match(as.character(parent_ids), peak_id)
pos <- which(!is.na(matches))
# if there's more than one fragment peak
if (length(pos)>0) {
# then scale by the relative intensities of the spectrum
fragment_peaks <- ms2[pos, ]
fragment_intensities <- fragment_peaks$intensity
max_intense <- max(fragment_intensities)
fragment_intensities <- fragment_intensities / max_intense
ms2[pos, ]$intensity <- fragment_intensities
}
}
}
source('extractFragmentFeatures.R')
results <- extract_ms2_fragment_df(ms1, ms2, prev_fragment_file)
source('extractFragmentFeatures.R')
results <- extract_ms2_fragment_df(ms1, ms2, prev_fragment_file)
source('extractFragmentFeatures.R')
results <- extract_ms2_fragment_df(ms1, ms2, prev_fragment_file)
source('extractFragmentFeatures.R')
results <- extract_ms2_fragment_df(ms1, ms2, prev_fragment_file)
fragment_df <- results$fragment_df
ms2 <- results$ms2
write.table(fragment_df, file=fragments_out, col.names=NA, row.names=T, sep=",")
